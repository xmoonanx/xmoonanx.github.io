---
title: "[CV] Computer Vision(2-1): Image Processing - Binary image processing"

categories: [CV, Computer Vision]
tags:
  - [CV, Computer Vision, python]
toc: true
toc_sticky: true
use_math: true

date: 2025-03-27
last_modified_at: 2025-03-27
image: 
---
ğŸ‘“Computer Vision ì •ë¦¬

## Binary Image Processing 
---
* **<span style="color: #008000">Binary Image</span>**: an image only consisting of `0â€™s` and `1â€™s`(í‘ë°± ì´ë¯¸ì§€)
* **<span style="color: #008000">Binarization(ì´ì§„í™”)</span>**: binary image occurs after thresholding operation

* ![alt text](../assets/img/CV/thresholding.png)
> **thresholding**: Tê°’(ì„ê³„ê°’)ì„ ì„¤ì •í•´ì„œ Të³´ë‹¤ í¬ë©´ 1, ì‘ìœ¼ë©´ 0

![alt text](../assets/img/CV/ex_thresholding.png)
> ì´ë¯¸ì§€ì˜ histogramì„ êµ¬í•´ì„œ ë‘ ê°œì˜ í”¼í¬ ì‚¬ì´ì˜ ê³¨ì§œê¸°ë¥¼ ì°¾ìœ¼ë©´ ë¨  
> T=60ì„ ì„¤ì •í•˜ê³  ì´ë³´ë‹¤ í¬ë©´ 1, ì‘ìœ¼ë©´ 0ìœ¼ë¡œ ì„¤ì • â†’ ìš°ë¦¬ê°€ **ì›í•˜ëŠ” targetë§Œ detection ê°€ëŠ¥**  
> ê·¸ëŸ¼ ì–´ë–¤ ìˆ˜ê°€ ì´ìƒì ì¸ `threshold`ì¸ê°€?

{:.prompt-tip}
> ê·¸ê±¸ êµ¬í•˜ê¸° ìœ„í•œ algorithm = **Otsu's Binarization Algorithm**
>

### Otsu's Binarization Algorithm
---
* histogramì—ì„œ **ê°€ì¥ í‘œì¤€í¸ì°¨, ë¶„ì‚°ì´ ì‘ì€ ì§€ì ì´ ì´ìƒì ì¸ Tê°’**ì´ë‹¤.
* Objective function: make **two split pixel sets as uniform as possible**
  * Two sets of pixels after splitting should have **small variances**
* Otsuâ€™s algorithm **minimizes the weighted within-class variance**:

![alt text](../assets/img/CV/Otsu.png)
> Tê°€ ê°€ì¥ ì‘ì€ `weight`ì™€ `variance`ë¥¼ êµ¬í•´ì•¼í•¨

ìˆ˜ì‹ ëª©í‘œ:
$$T=\argmin_{t}v_within(t)$$

ë‚´ë¶€ ë¶„ì‚°(within-class variance) ê³„ì‚°:
$$v_within(t)=w_0(t)v_0(t)+w_1(t)v_1(t)$$
* $w_0,w_1$: ë‘ ê·¸ë£¹ì˜ í”½ì…€ ë¹„ìœ¨(Weight)
* $u_0,u_1$: ê·¸ë£¹ë³„ í‰êµ°(mean)
* $v_0,v_1$: ê·¸ë£¹ë³„ ë¶„ì‚°(variance)

ìˆ˜ì‹ ì •ë¦¬ë¥¼ í•˜ë‹¤ë³´ë©´ ë‹¤ìŒê³¼ ê°™ì€ í˜•íƒœê°€ ë‚˜ì˜´:
$$T=\argmax_{t}v_between(t)$$
$$v_between(t)=w_0(t)(1-w_0(t))(u_0(t)-u_1(t))^2$$
â†’ **ë‘ ê·¸ë£¹ ê°„ì˜ í‰ê·  ì°¨ì´ê°€ ê°€ì¥ í° ìˆœê°„ì´ ê°€ì¥ ì¢‹ì€ $ğ‘‡$ê°’**

![alt text](../assets/img/CV/Otsuex.png)
> ì˜¤ë¥¸ìª½ ë‹¬ ì´ë¯¸ì§€ê°€ ì´ì¤‘ í”¼í¬ê°€ ê°€ì¥ ì˜ë‚˜íƒ€ë‚˜ë¯€ë¡œ ë¶„ë¦¬ê°€ ì˜ëœë‹¤!

### Morphology
---
**<span style="color: #008000">Morphology</span>**: **ì´ë¯¸ì§€ ì•ˆì— ìˆëŠ” ë¬¼ì²´ì˜ í˜•íƒœë¥¼ ë³€ê²½í•˜ëŠ” ì—°ì‚°**
* Can be applied to both **binary and grayscale images, but commonly used in binary images**

âœ…**Morphological operations**:  
  * Define a **structuring element**
  * **Convolve** the structuring element with the image
  * **Thresholding the result of the convolution**
  * input, output ë‘˜ë‹¤ binary image

![alt text](../assets/img/CV/Structuring_Element.png)
> Structuring Element  
> í•„í„° ê°™ì€ ëŠë‚Œ â†’ ì´ë¯¸ì§€ ìœ„ì— ì´ê±¸ ì˜¬ë ¤ì„œ ì–´ë–¤ í”½ì…€ì„ ë°”ê¿€ì§€ ê²°ì •  
> **Anchor point**: êµ¬ì¡° ìš”ì†Œì—ì„œ ì¤‘ì‹¬ ì—­í• ì„ í•˜ëŠ” ì¢Œí‘œ, ì´ ì ì„ ê¸°ì¤€ìœ¼ë¡œ ì´ë¯¸ì§€ì— ì ìš©

![alt text](../assets/img/CV/Morphologyex.png)
> Morphology operation ì ìš© ì˜ˆì‹œ

#### Dilation(íŒ½ì°½) & Erosion(ì¹¨ì‹)
* **<span style="color: #008000">Dilation</span>**:
  * êµ¬ì¡° ìš”ì†Œ(Structuring Element)ê°€ ì´ë¯¸ì§€ì˜ **1ìœ„ì¹˜ì— ê±¸ì¹  ìˆ˜ë§Œ ìˆìœ¼ë©´ ê·¸ ìë¦¬ë¥¼ 1ë¡œ ë°”ê¿ˆ**
  * â†’ **í˜•íƒœê°€ êµµì–´ì§€ê³  ì—°ê²°ì„±ì´ ë†’ì•„ì§**
* **<span style="color: #008000">Erosion</span>**
  * êµ¬ì¡° ìš”ì†Œê°€ ì´ë¯¸ì§€ì˜ **1ìœ„ì¹˜ ì „ë¶€ì— ì™„ì „íˆ ë§ì•„ì•¼ ê·¸ ìë¦¬ë¥¼ 1ë¡œ ìœ ì§€**
  * â†’ **í˜•íƒœê°€ ê¹ì´ê³  ì–‡ì•„ì§**

![alt text](../assets/img/CV/Dilation.png)
> ì›ë˜ ì´ë¯¸ì§€ì— `structuring element`ê°€ ë‹¿ëŠ” ê³³ì´ ìˆìœ¼ë©´ â†’ 1ë¡œ ì±„ì›€

![alt text](../assets/img/CV/Erosion.png)
> `structuring element` ì „ë¶€ê°€ í•´ë‹¹ ì´ë¯¸ì§€ ì˜ì—­ì— ë‹¤ ë§ì§€ ì•Šìœ¼ë©´ â†’ 0ìœ¼ë¡œ ë§Œë“¦

#### Opening & Closing
* **<span style="color: #008000">Opening</span>(ì¹¨ì‹ í›„ íŒ½ì°½)**
  * **ì‘ì€ ë…¸ì´ì¦ˆ ì œê±°**ì— íš¨ê³¼ì 
  * ëª¨ì–‘ ìœ ì§€ + ì‘ì€ ì  ì‚¬ë¼ì§
* **<span style="color: #008000">Closing</span>(íŒ½ì°½ í›„ ì¹¨ì‹)**
  * **ì‘ì€ êµ¬ë© ì±„ìš°ê¸°**ì— íš¨ê³¼ì 
  * ë‚´ë¶€ì˜ í‹ˆì´ë‚˜ ê¹¨ì§„ ë¶€ë¶„ì„ ë©”ì›Œì¤Œ

![alt text](Opening_Closing.png)
> Opening & Closing ì˜ˆì‹œ

### Connect Component
---
**<span style="color: #008000">Connect Component(ì—°ê²° ì„±ë¶„)</span>**: **ì„œë¡œ ì¸ì ‘í•œ í”½ì…€ë“¤ì˜ ì§‘í•©**ì„ ì˜ë¯¸

* **Pixel adjacency(í”½ì…€ ì¸ì ‘ì„±)**: **ì–´ë–¤ í”½ì…€ë“¤ê³¼ ë¶™ì–´ìˆëŠ”ì§€ë¥¼ ì •ì˜**
  * **ğ’©4-adjacency (ğ’©4-connectivity)**: a pixel has 4 neighbors (N,S,E,W)
  * **ğ’©8-adjacency (ğ’©8-connectivity)**: a pixel has 8 neighbors (N,S,E,W, NE,NW,SE,SW)

![alt text](../assets/img/CV/Connect_Component.png)

![alt text](../assets/img/CV/Connect_Component_EX.png)
> N4ì—ì„œëŠ” ë™ì„œë‚¨ë¶ë§Œ ìƒê°í•˜ê¸° ë•Œë¬¸ì— ê° ì§‘í•©ì´ ë”°ë¡œë”°ë¡œ ì •ì˜ë¨
> N8ì—ì„œëŠ” 8ë°©í–¥ ëª¨ë‘ ê´€ê³„ë¡œ ìƒê°í•´ì„œ 2ê°œì˜ connected compoenetê°€ ìƒê¹€

#### Connected Component Labeling
---
í”½ì…€ ë©ì–´ë¦¬(Connected Component)ë¥¼ ì°¾ì•„ì•¼ í•˜ëŠ”ë°, ê·¸ ë°©ë²•ì´ ë°”ë¡œ **<span style="color: #008000">Labeling(ë ˆì´ë¸”ë§)</span>**
* ê°™ì€ ì—°ê²°ëœ í”½ì…€ ê·¸ë£¹ì„ **ê°™ì€ ìˆ«ìë¡œ ë§ˆí‚¹**
```python
# Connected Component LabelingAlgorithm
# Flood-fill algorithm to label connected components
Input: Binary image ğ‘ğ‘—,ğ‘–,0â‰¤ğ‘—â‰¤ğ‘€âˆ’1,0â‰¤ğ‘–â‰¤ğ‘âˆ’1
Output: Labelled image lğ‘—,ğ‘–,0â‰¤ğ‘—â‰¤ğ‘€âˆ’1,0â‰¤ğ‘–â‰¤ğ‘âˆ’1

Initialize l: l(j,i) = 0 if b(j,i) = 0, l(j,i)=-1 if b(j,i)=1
l(0,:) = l(M-1, :) = l(:,0) = l(:, N-1) = 0
label := 1;
for (j=1 to M-2)
  for (i=1 to N-2) {
    if (l(j,i) == -1) { 
      flood_fill4(l, j, I, label);
      label++;
      }   
  }

# ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ í”½ì…€ì„ ì¬ê·€ì ìœ¼ë¡œ ë”°ë¼ê°€ë©° ê°™ì€ ë ˆì´ë¸”ì„ ë¶™ì´ëŠ” ë°©ì‹
# ë¬¸ì œì : ì¬ê·€ í˜¸ì¶œì´ ë„ˆë¬´ ê¹Šì–´ì§€ë©´ Stack Overflow ë°œìƒ
function flood_fill4(l,j,l,label) {
  if(l(j,i)==-1) {
    l(j,i)=label;
    flood_fill4(l,j,i+1, label);
    flood_fill4(l,j-1,i, label);
    flood_fill4(l,j,i-1, label);
    flood_fill4(l,j+1,I,label);
  }
}
```

![alt text](../assets/img/CV/overflow_sol.png)
> ì¬ê·€ ëŒ€ì‹  ë°˜ë³µë¬¸ ê¸°ë°˜ â†’ Stack overflowë°œìƒì„ ë°©ì§€
> **í(Queue)**ë¥¼ ì´ìš©í•´ í•œ ì¤„(ë¼ì¸)ì„ í•œ ë²ˆì— ì²˜ë¦¬