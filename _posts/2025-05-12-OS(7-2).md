---
title: "[OS] Operating System(7-2): Synchronization(Windows, Linux, POSIX)"

categories: [CS, Operating System, OS]
tags:
  - [CS, OS, Operating System, Scheduling]
toc: true
toc_sticky: true
use_math: true


date: 2025-05-12
last_modified_at: 2025-05-12
---
>ğŸ€ ìš´ì˜ì²´ì œ ì „ê³µ ìˆ˜ì—… ì •ë¦¬

## Kernel Synchronizatoin - Windows
---
* **<span style="color: #008000">uniprocessor systems</span>**: **Interrupt Mask**ë¥¼ ì‚¬ìš©í•˜ì—¬ global resourceì— ëŒ€í•œ ì ‘ê·¼ì„ ë³´í˜¸
  * **<span style="color: #008000">Interrupt Mask</span>**: íŠ¹ì • ì¸í„°ëŸ½íŠ¸ì˜ ì²˜ë¦¬ë¥¼ ì¼ì‹œì ìœ¼ë¡œ ì°¨ë‹¨ â†’ ì¤‘ìš”í•œ ì½”ë“œ ì„¹ì…˜ì´ ë°©í•´ë°›ì§€ ì•Šê³  ì‹¤í–‰ë¨

* **<span style="color: #008000">multiple processor system</span>**: spinlock ì‚¬ìš©í•˜ì—¬ global resourceì— ëŒ€í•œ ì ‘ê·¼ì„ ë³´í˜¸
  * **<span style="color: #008000">spinlock</span>**: ë½ì„ íšë“í•  ë•Œê¹Œì§€ ê³„ì†í•´ì„œ í™•ì¸í•˜ëŠ”(spinning) ë°©ì‹ì˜ ë½
  * spinlockì„ ê°€ì§„ ìŠ¤ë ˆë“œëŠ” **never be preempted**
  * â†’ íš¨ìœ¨ì„± ë•Œë¬¸!: **spinlockì„ ê°€ì§„ ìŠ¤ë ˆë“œê°€ ì„ ì ë˜ë©´ deadlockì´ ë°œìƒí•  ìˆ˜ ìˆë‹¤**

### Dispatcher Objects
* **Dispatcher Objects**: ìœˆë„ìš°ê°€ ì œê³µí•˜ëŠ” ì‚¬ìš©ì ë ˆë²¨ì—ì„œ ë™ì‘í•˜ëŠ” ê°ì²´(mutex, semaphore, events, timers)
  * `mutex`: ìƒí˜¸ ë°°ì œë¥¼ ìœ„í•œ ê°ì²´
  * `semaphore`: ì œí•œëœ ìì› ê´€ë¦¬
  * `events`: ì¡°ê±´ ë§Œì¡± ì‹œ ê¸°ë‹¤ë¦¬ëŠ” ìŠ¤ë ˆë“œì—ê²Œ `notify()`
  * `timers`: ì‹œê°„ì´ ë§Œë£Œë˜ë©´ í•˜ë‚˜ ì´ìƒì˜ ìŠ¤ë ˆë“œì— `notify()`

dispatcher objectëŠ” ë‘ ê°œì˜ ìƒíƒœê°€ ì¡´ì¬:
1. **Signaled State**: ê°ì²´ê°€ ì‚¬ìš© ê°€ëŠ¥í•œ ìƒíƒœ
2. **Non-signal State**: ìŠ¤ë ˆë“œê°€ ë¸”ë¡ë˜ëŠ” ìƒíƒœ

{:.prompt-tip}
> ê° dispatcher objectì—ëŠ” waiting queueê°€ ì¡´ì¬!  
> Objectê°€ signaled-stateë¡œ ë°”ë€Œë©´ queueì— ëŒ€ê¸°í•˜ë˜ ëª¨ë“  ìŠ¤ë ˆë“œ ë˜ëŠ” ì¼ë¶€ë¥¼ ê¹¨ìš´ë‹¤
>

![alt text](../assets/img/OS/mutexobject.png)
> Mutex Dispatcher Object

ì‘ë™ ë°©ì‹:
1. ìŠ¤ë ˆë“œê°€ `mutex_lock`ì„ íšë“í•˜ë©´ mutexëŠ” Non-signal state
2. ì†Œìœ ì ìŠ¤ë ˆë“œê°€ `mutex_lock`ë¥¼ í•´ì œí•˜ë©´ Signal state
3. ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ `mutex_lock`íšë“ ê°€ëŠ¥

## Linux Synchronization
---
2.6ë²„ì „ ì´ì „ì˜ ì»¤ë„ì—ì„œëŠ” disables interruptë¥¼ ì‚¬ìš©í•´ì„œ CSë¥¼ êµ¬í˜„

âœ…2.6ì´í›„ ë²„ì „:  
* **<span style="color: #008000">fully preemptive</span>**ë°©ì‹ ì±„íƒ
* ì»¤ë„ ì½”ë“œ ì‹¤í–‰ ì¤‘ì—ë„ **ë” ë†’ì€ ìš°ì„ ìˆœìœ„ì˜ í”„ë¡œì„¸ìŠ¤ê°€ ìˆìœ¼ë©´ í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ë¥¼ ì„ ì í•  ìˆ˜ ìˆìŒ**

### Linux provides
---
1. **<span style="color: #008000">Semaphore</span>**
* ìì›ì˜ ê°œìˆ˜ë¥¼ ì¹´ìš´íŒ…í•˜ì—¬ ì œí•œëœ ìˆ˜ì˜ ìŠ¤ë ˆë“œë§Œ ìì›ì— ì ‘ê·¼ ê°€ëŠ¥
2. **<span style="color: #008000">Atomic Integers</span>**
* ì›ìì  ì—°ì‚°ì„ ì§€ì›í•˜ëŠ” íŠ¹ìˆ˜í•œ ì •ìˆ˜ íƒ€ì…(`atomic_t`)
3. **<span style="color: #008000">Spinlock</span>**
* ë½ì„ íšë“í•  ë•Œê¹Œì§€ ê³„ì†í•´ì„œ í™•ì¸í•˜ëŠ”(spinning) ë°©ì‹ì˜ ë½
4. **<span style="color: #008000">Mutex Locks</span>**
* ìƒí˜¸ ë°°ì œ(Mutual Exclusion)ë¥¼ êµ¬í˜„í•˜ëŠ” ë½

* ë¦¬ëˆ…ìŠ¤ì˜ ìŠ¤í•€ë½ê³¼ ë®¤í…ìŠ¤ ë½ì€ **nonrecursive** íŠ¹ì„±
* â†’ **ë½ì„ ì´ë¯¸ íšë“í•œ ìƒíƒœì—ì„œ ë‹¤ì‹œ íšë“í•˜ë ¤ê³  í•˜ë©´ ë°ë“œë½ì´ ë°œìƒí•  ìˆ˜ ìˆìŒ**

* **Single-CPU System**: **disabling kernel preemption** ì‚¬ìš©
  * spinlockì€ ë‹¨ì¼ CPUì—ì„œ ë¹„íš¨ìœ¨ì ì´ê¸° ë•Œë¬¸

* **SMP(Symmetric Multi-Processing)**: **spinlock** ì‚¬ìš©
  * ì—¬ëŸ¬ CPUê°€ ë™ì‹œì— ì‘ì—… ì²˜ë¦¬ê°€ ë˜ê¸° ë•Œë¬¸ì— spinlock íš¨ìœ¨ í–¥ìƒ

* ì»¤ë„ì— ìˆëŠ” taskê°€ lock ê°€ì§€ê³  ìˆìœ¼ë©´ **ì´ taskëŠ” nonpreemptive**
* **preemptiveí•˜ë©´ deadlock ë°œìƒ ê°€ëŠ¥**
* í˜„ì¬ ê°€ì§€ê³  ìˆëŠ” lockì˜ ìˆ˜ë¥¼ `preempt_count`ë¼ëŠ” ë³€ìˆ˜ì— ì €ì¥
* `preempt_count`=0 ì´ë©´ **preemption ê°€ëŠ¥!!**

### Atomic Variables
---
* atimic_t type:
```c
atomic_t counter;
int value;
```

**ì£¼ìš” atomic ì—°ì‚°**:
![alt text](../assets/img/OS/atomicoperation.png)

**C11 atomic library**:
![alt text](../assets/img/OS/atomicoperationli.png)

* `atomic_init(_Atomic(T) *object, T value)`: ë¹„ì›ìì ìœ¼ë¡œ ì´ˆê¸°í™”
* `T atomic_load(_Atomic(T) *object)`: ì›ìì ìœ¼ë¡œ ê°’ ì½ê¸°
* `void atomic_store(_Atomic(T) *object, T desired)`: ì›ìì ìœ¼ë¡œ ê°’ ì €ì¥
* `T atomic_exchange(_Atomic(T) *object, T desired)`: ì›ìì ìœ¼ë¡œ ê°’ êµí™˜
* `_Bool atomic_compare_exchange_strong/_weak(_Atomic(T) *object, T *expected, T desired)`: ë¹„êµ í›„ êµí™˜
* `T atomic_fetch_add/_and/_or/_sub/_xor(_Atomic(T) *object, T operand)`: ì—°ì‚° í›„ ì´ì „ ê°’ ë°˜í™˜

## POSIX Synchronization
---
POSIX APIëŠ” ë©€í‹°ìŠ¤ë ˆë”© í”„ë¡œê·¸ë˜ë°ì„ ìœ„í•œ ë‹¤ì–‘í•œ ë™ê¸°í™” ë©”ì»¤ë‹ˆì¦˜ì„ ì œê³µ

### POSIX Provides
---
* **<span style="color: #008000">Mutex Locks</span>**: ìƒí˜¸ ë°°ì œë¥¼ ìœ„í•œ ë½
* **<span style="color: #008000">Spin Locks</span>**: ì§§ì€ ëŒ€ê¸° ì‹œê°„ì„ ìœ„í•œ ë½
* **<span style="color: #008000">Semaphores</span>**: ìì› ì¹´ìš´íŒ…ì„ ìœ„í•œ ë©”ì»¤ë‹ˆì¦˜
* **<span style="color: #008000">Condition Variables</span>**: íŠ¹ì • sì¡°ê±´ì´ ì¶©ì¡±ë  ë•Œê¹Œì§€ ìŠ¤ë ˆë“œë¥¼ ëŒ€ê¸°ì‹œí‚¤ëŠ” ë©”ì»¤ë‹ˆì¦˜

#### ì£¼ìš” í•¨ìˆ˜:

```c
// ë®¤í…ìŠ¤ ìƒì„± ë° íŒŒê´´
int pthread_mutex_destroy(pthread_mutex_t *mutex);
int pthread_mutex_init(pthread_mutex_t *restrict mutex, 
                      const pthread_mutexattr_t *restrict attr);

// ì •ì  ì´ˆê¸°í™”
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// ë®¤í…ìŠ¤ ì ê¸ˆ ë° í•´ì œ
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

#### ë®¤í…ìŠ¤ ì‚¬ìš© ì˜ˆì‹œ
* ìƒì„± ë° ì´ˆê¸°í™”:

```c
#include <pthread.h>

pthread_mutex_t mutex;

/* ë®¤í…ìŠ¤ ë½ ìƒì„± ë° ì´ˆê¸°í™” */
pthread_mutex_init(&mutex, NULL);
```

* íšë“ ë° í•´ì œ:

```c
/* ë®¤í…ìŠ¤ ë½ íšë“ */
pthread_mutex_lock(&mutex);

/* ì„ê³„ ì˜ì—­ */

/* ë®¤í…ìŠ¤ ë½ í•´ì œ */
pthread_mutex_unlock(&mutex);
```

#### POSIX Spinlock
* spinlock ì£¼ìš” í•¨ìˆ˜:

```c
#include <pthread.h>

int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
int pthread_spin_destroy(pthread_spinlock_t *lock);

int pthread_spin_lock(pthread_spinlock_t *lock);
int pthread_spin_trylock(pthread_spinlock_t *lock);
int pthread_spin_unlock(pthread_spinlock_t *lock);
```

* **`int pshared`ì—ì„œ pshared ì˜µì…˜**:
  * **PTHREAD_PROCESS_PRIVATE**: í”„ë¡œì„¸ìŠ¤ ë‚´ ìŠ¤ë ˆë“œê°„ ê³µìœ  (ê¸°ë³¸ê°’)
  * **PTHREAD_PROCESS_SHARED**: í”„ë¡œì„¸ìŠ¤ ì™¸ ìŠ¤ë ˆë“œê°„ ê³µìœ  (ë½ì´ ê³µìœ  ë©”ëª¨ë¦¬ ìƒì— ìˆì–´ì•¼ í•¨)

#### POSIX Semaphore
POSIXëŠ” ë‘ ê°€ì§€ ë²„ì „ì˜ ì„¸ë§ˆí¬ì–´ ì œê³µ
1. **<span style="color: #008000">Named Semaphores</span>**
* **ì„œë¡œ ê´€ë ¨ ì—†ëŠ” í”„ë¡œì„¸ìŠ¤ ê°„**ì—ë„ ê³µìœ  ê°€ëŠ¥

2. **<span style="color: #008000">Unnamed Semaphores</span>**
* **ê´€ë ¨ëœ í”„ë¡œì„¸ìŠ¤(ì˜ˆ: ë¶€ëª¨-ìì‹) ê°„**ì—ë§Œ ê³µìœ  ê°€ëŠ¥

##### ê³µí†µ í•¨ìˆ˜
* ``sem_wait(sem_t *sem)``: ì„¸ë§ˆí¬ì–´ ê°’ì„ ê°ì†Œì‹œí‚¤ê³ , ê°’ì´ 0ì´ë©´ ë¸”ë¡ë¨ (P ì—°ì‚°)
* `sem_post(sem_t *sem)`: ì„¸ë§ˆí¬ì–´ ê°’ì„ ì¦ê°€ì‹œí‚¤ê³ , ëŒ€ê¸° ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ ê¹¨ì›€ (V ì—°ì‚°)
* `sem_trywait(sem_t *sem)`: ë¹„ë¸”ë¡œí‚¹ ë°©ì‹ìœ¼ë¡œ wait ì‹œë„
* `sem_timedwait(sem_t *sem, const struct timespec *abs_timeout)`: ì œí•œ ì‹œê°„ ë‚´ì— wait ì‹œë„
* `sem_getvalue(sem_t *sem, int *sval)`: í˜„ì¬ ì„¸ë§ˆí¬ì–´ ê°’ ì¡°íšŒ

##### Named semaphore í•¨ìˆ˜
* `sem_t *sem_open(const char *name, int oflag)`: ê¸°ì¡´ ì„¸ë§ˆí¬ì–´ ì—´ê¸°
* `sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value)`: ìƒˆ ì„¸ë§ˆí¬ì–´ ìƒì„± ë° ì´ˆê¸°í™”
* `int sem_close(sem_t *sem)`: ì„¸ë§ˆí¬ì–´ ë‹«ê¸° (í”„ë¡œì„¸ìŠ¤ì˜ ì°¸ì¡°ë§Œ ì œê±°)
* `int sem_unlink(const char *name)`: ì„¸ë§ˆí¬ì–´ ì´ë¦„ ì œê±° (ëª¨ë“  ì°¸ì¡°ê°€ ë‹«íˆë©´ ì„¸ë§ˆí¬ì–´ íŒŒê´´)


##### Unnamed semaphore í•¨ìˆ˜
* `int sem_init(sem_t *sem, int pshared, unsigned int value)`: ì„¸ë§ˆí¬ì–´ ì´ˆê¸°í™”
* `int sem_destroy(sem_t *sem)`: ì„¸ë§ˆí¬ì–´ íŒŒê´´

##### Named Semaphores
* **Named Semaphores**: íŒŒì¼ ì‹œìŠ¤í…œ ê²½ë¡œëª…ìœ¼ë¡œ ì‹ë³„ë˜ë©°, ê´€ë ¨ ì—†ëŠ” í”„ë¡œì„¸ìŠ¤ ê°„ì—ë„ ê³µìœ  ê°€ëŠ¥

* **ìƒì„± ë° ì´ˆê¸°í™”:**

```c
#include <semaphore.h>
sem_t *sem;

/* ì„¸ë§ˆí¬ì–´ ìƒì„± ë° 1ë¡œ ì´ˆê¸°í™” */
sem = sem_open("SEM", O_CREAT, 0666, 1);
```

* `SEM`: ì„¸ë§ˆí¬ì–´ ì´ë¦„
* `O_CREAT`: ì„¸ë§ˆí¬ì–´ê°€ ì—†ìœ¼ë©´ ìƒì„±
* `0666`: ì ‘ê·¼ ê¶Œí•œ (rw-rw-rw-)
  * rw ê¶Œí•œì´ ìˆì–´ì•¼ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ê°€ ì‚¬ìš© ê°€ëŠ¥
* `1`: ì´ˆê¸° ì„¸ë§ˆí¬ì–´ ê°’

* **íšë“ ë° í•´ì œ:**

```c
/* ì„¸ë§ˆí¬ì–´ íšë“ */
sem_wait(sem);

/* ì„ê³„ ì˜ì—­ */

/* ì„¸ë§ˆí¬ì–´ í•´ì œ */
sem_post(sem);
```

##### Unnamed Semaphore
* **Unnamed Semaphore**: ì´ë¦„ì´ ì—†ê³  ë©”ëª¨ë¦¬ ì£¼ì†Œë¡œ ì°¸ì¡°, **ì£¼ë¡œ ê°™ì€ í”„ë¡œì„¸ìŠ¤ ë‚´ì˜ ìŠ¤ë ˆë“œ ê°„ ë˜ëŠ” ê´€ë ¨ í”„ë¡œì„¸ìŠ¤ ê°„(ì˜ˆ: ë¶€ëª¨-ìì‹)ì— ì‚¬ìš©**

* **ìƒì„± ë° ì´ˆê¸°í™”**:

```c
#include <semaphore.h>
sem_t sem;

/* ì„¸ë§ˆí¬ì–´ ìƒì„± ë° 1ë¡œ ì´ˆê¸°í™” */
sem_init(&sem, 0, 1);
```

* `&sem`: ì„¸ë§ˆí¬ì–´ í¬ì¸í„°
* `0`: pshared ê°’(ê³µìœ  ë²”ìœ„)
  * `0`: ê°™ì€ í”„ë¡œì„¸ìŠ¤ ë‚´ ìŠ¤ë ˆë“œ ê°„ ê³µìœ 
  * `Non-zero`: í”„ë¡œì„¸ìŠ¤ ê°„ ê³µìœ (ì„¸ë§ˆí¬ì–´ê°€ shared memoryì— ìˆì–´ì•¼ í•¨)
* `1`: ì´ˆê¸° ì„¸ë§ˆí¬ì–´ ê°’

* **íšë“ ë° í•´ì œ**:

```c
/* ì„¸ë§ˆí¬ì–´ íšë“ */
sem_wait(&sem);

/* ì„ê³„ ì˜ì—­ */

/* ì„¸ë§ˆí¬ì–´ í•´ì œ */
sem_post(&sem);
```

#### POSIX Condition Variables
* **ì¡°ê±´ ë³€ìˆ˜**: **ëŒ€ê¸°ì—´ì˜ ì´ë¦„**, ìŠ¤ë ˆë“œë“¤ì€ íŠ¹ì • ì¡°ê±´ì´ ì¶©ì¡±ë  ë•Œê¹Œì§€ ì´ ëŒ€ê¸°ì—´ì—ì„œ ê¸°ë‹¤ë¦¬ê³ , ì¡°ê±´ì´ ì¶©ì¡±ë˜ë©´ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì‹ í˜¸ë¥¼ ë³´ë‚´ì–´ ëŒ€ê¸° ì¤‘ì¸ ìŠ¤ë ˆë“œë¥¼ ê¹¨ìš´

* POSIXëŠ” ì¼ë°˜ì ìœ¼ë¡œ C/C++ì—ì„œ ì‚¬ìš©ë¨, **C/C++ ì–¸ì–´ëŠ” Monitor ì œê³µ X**
* ê·¸ë˜ì„œ POSIX ì¡°ê±´ë³€ìˆ˜ëŠ” **mutual exclusion**ì„ ìœ„í•´ POSIX mutex lockê³¼ ê°™ì´ ì‚¬ìš©ëœë‹¤

* **ì´ˆê¸°í™” ë° íŒŒê´´:**
```c
pthread_mutex_t mutex;
pthread_cond_t cond_var;

// ë™ì  ì´ˆê¸°í™”
pthread_mutex_init(&mutex, NULL);
pthread_cond_init(&cond_var, NULL);

// ì •ì  ì´ˆê¸°í™”
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
```

**ì£¼ìš” í•¨ìˆ˜**:
* `pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex)`: ì¡°ê±´ì´ ì¶©ì¡±ë  ë•Œê¹Œì§€ ëŒ€ê¸°
* `pthread_cond_timedwait(...)`: ì œí•œ ì‹œê°„ ë‚´ì—ì„œ ì¡°ê±´ ëŒ€ê¸°
* `pthread_cond_signal(pthread_cond_t *cond)`: ëŒ€ê¸° ì¤‘ì¸ ìŠ¤ë ˆë“œ í•˜ë‚˜ë¥¼ ê¹¨ì›€
* `pthread_cond_broadcast(pthread_cond_t *cond)`: ëŒ€ê¸° ì¤‘ì¸ ëª¨ë“  ìŠ¤ë ˆë“œë¥¼ ê¹¨ì›€

**ì¡°ê±´ ë³€ìˆ˜ ì‚¬ìš© íŒ¨í„´**:
* ì¡°ê±´ì„ ê¸°ë‹¤ë¦¬ëŠ” ìŠ¤ë ˆë“œ (a == bê°€ ë˜ê¸°ë¥¼ ê¸°ë‹¤ë¦¼):

```c
pthread_mutex_lock(&mutex);
while (a != b) {
    pthread_cond_wait(&cond_var, &mutex);
}
pthread_mutex_unlock(&mutex);
```

1. **release mutex lock**: `pthread_cond_wait()`ëŠ” ë®¤í…ìŠ¤ ë½ì„ í’€ì–´ì£¼ê³  ëŒ€ê¸° ìƒíƒœ ëŒì…
2. **wait on the condition variable**: ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì‹ í˜¸ë¥¼ ë³´ë‚¼ ë•Œê¹Œì§€ ëŒ€ê¸°
3. ê¹¨ì–´ë‚˜ë©´ â†’ **acquire mutex lock and return**

âœ…**while ë£¨í”„ë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ **:  
`pthread_cond_wait()`ëŠ” ë®¤í…ìŠ¤ ë½ì„ í’€ê¸° ë•Œë¬¸ì— **aë‚˜ bì˜ ê°’ì´ ë³€ê²½ë  ìˆ˜ ìˆìŒ**. ë”°ë¼ì„œ **while ë£¨í”„ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¡°ê±´ì„ ë‹¤ì‹œ ê²€ì‚¬í•˜ëŠ” ê²ƒì´ ë§¤ìš° ì¤‘ìš”**

* ì¡°ê±´ì„ ì‹ í˜¸í•˜ëŠ” ìŠ¤ë ˆë“œ:
```c
pthread_mutex_lock(&mutex);
a = b;  // ì¡°ê±´ì„ ì¶©ì¡±ì‹œí‚´
pthread_cond_signal(&cond_var);
pthread_mutex_unlock(&mutex);
```

* `pthread_cond_signal(&cond_var)`
  * ì¡°ê±´ë³€ìˆ˜ì—ì„œ ê¸°ë‹¤ë¦¬ê³  ìˆëŠ” ìŠ¤ë ˆë“œê°€ ìˆìœ¼ë©´ ê¹¨ì–´ë‚˜ì˜´
  * ì´ë•Œ ê¹¨ì–´ë‚œ ìŠ¤ë ˆë“œëŠ” mutex lockì„ íšë“í•´ì•¼ í•˜ë¯€ë¡œ ì´ ì˜ˆì œì˜ ê²½ìš° ì•„ì§ ì§„í–‰ì´ ì •ì§€ëœ ìƒíƒœ

* `pthread_mutex_unlock(&mutex)`
  * a=bë¥¼ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ ê±¸ì—ˆë˜ lockì„ signalì„ í˜¸ì¶œí•œ í›„ **unlockì„ í•˜ê²Œë˜ë©´, ê¹¨ì–´ë‚¬ì§€ë§Œ ì•„ì§ ëŒ€ê¸°ìƒíƒœì— ìˆë˜ ìŠ¤ë ˆë“œê°€ lockì„ íšë“í•œ í›„ ë‹¤ìŒì„ ì§„í–‰í•  ìˆ˜ ìˆë‹¤**

* **pthread_cond_signal vs pthread_cond_broadcast**
`pthread_cond_signal`: **í•˜ë‚˜ì˜ ì‘ì—…ë§Œ ì²˜ë¦¬í•˜ë©´ ë˜ëŠ” ê²½ìš° ì‚¬ìš©**(ì˜ˆ: ìƒì‚°ì-ì†Œë¹„ìì—ì„œ í•˜ë‚˜ì˜ ì•„ì´í…œë§Œ ì¤€ë¹„ëœ ê²½ìš°)
* ëŒ€ê¸° ì¤‘ì¸ ìŠ¤ë ˆë“œ **í•˜ë‚˜ë§Œ** ê¹¨ì›€
* ì–´ë–¤ ìŠ¤ë ˆë“œê°€ ê¹¨ì–´ë‚ ì§€ëŠ” ì‹œìŠ¤í…œì´ ê²°ì •

`pthread_cond_broadcast`: ëª¨ë“  ëŒ€ê¸° ì¤‘ì¸ ìŠ¤ë ˆë“œê°€ ì¡°ê±´ì„ ë‹¤ì‹œ í™•ì¸í•´ì•¼ í•˜ëŠ” ê²½ìš°(ì˜ˆ: í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì‹ í˜¸)
* ëŒ€ê¸° ì¤‘ì¸ **ëª¨ë“  ìŠ¤ë ˆë“œ**ë¥¼ ê¹¨ì›€
* ëª¨ë“  ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ë®¤í…ìŠ¤ ë½ì„ íšë“í•˜ë ¤ê³  ê²½ìŸ
* í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë§Œ ë½ì„ íšë“í•˜ê³  ë‚˜ë¨¸ì§€ëŠ” ë‹¤ì‹œ ëŒ€ê¸°ìƒíƒœ

## Alternative Approaches
---
ì „í†µì ì¸ ë™ê¸°í™” ë©”ì»¤ë‹ˆì¦˜(ë®¤í…ìŠ¤, ì„¸ë§ˆí¬ì–´, ì¡°ê±´ ë³€ìˆ˜) ì™¸ì— **ë³‘ë ¬ í”„ë¡œê·¸ë˜ë°ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” Alternative Approaches ì¡´ì¬**

1. **Transactional Memory**
2. **OpenMP**
3. **Functional Programming Languages**

### Transactional Memory
---
* **Transactional Memory**:  ë°ì´í„°ë² ì´ìŠ¤ì˜ íŠ¸ëœì­ì…˜ ê°œë…ì„ ë©”ëª¨ë¦¬ ì—°ì‚°ì— ì ìš©í•œ ê²ƒ, **ì—¬ëŸ¬ ë©”ëª¨ë¦¬ ì½ê¸°-ì“°ê¸° ì—°ì‚°ì„ í•˜ë‚˜ì˜ ì›ìì  ë‹¨ìœ„ë¡œ ë¬¶ì–´ì„œ ì²˜ë¦¬**

ì „í†µì ì¸ ë°©ì‹(ë®¤í…ìŠ¤):
```c
void update() {
    acquire();  // ë®¤í…ìŠ¤ ë½ íšë“
    /* modify shared data */
    release();  // ë®¤í…ìŠ¤ ë½ í•´ì œ
}
```

íŠ¸ëœì­ì…˜ ë©”ëª¨ë¦¬:
```c
void update() {
    atomic {
        /* modify shared data */
    }
}
```

* íŠ¸ëœì­ì…˜ì€ `atomic{S}` êµ¬ë¬¸ì„ ì¶”ê°€í•˜ì—¬ ì™„ì„±í•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” **S ë‚´ì˜ ëª¨ë“  ì—°ì‚°ì´ ì›ìì ìœ¼ë¡œ ì‹¤í–‰ë˜ë„ë¡ ë³´ì¥**
  * ëª¨ë“  ì—°ì‚°ì´ ì˜¬ë°”ë¥´ê²Œ ì²˜ë¦¬ë˜ì–´ commit(í™•ì •)ë˜ê±°ë‚˜
  * ì·¨ì†Œë˜ì„œ ì›ì ìœ¼ë¡œ ë¡¤ë°±í•˜ëŠ” ë‘ ê°€ì§€ë§Œ ê°€ëŠ¥

### OpenMP
---
* **OpenMP**: **ì»´íŒŒì¼ëŸ¬ ì§€ì‹œë¬¸ê³¼ APIë¥¼ í†µí•´ ë³‘ë ¬ í”„ë¡œê·¸ë˜ë°ì„ ì§€ì›**, ê¸°ì¡´ì˜ ìˆœì°¨ ì½”ë“œë¥¼ **ê°„ë‹¨í•œ ì§€ì‹œë¬¸ ì¶”ê°€ë§Œìœ¼ë¡œ ë³‘ë ¬í™”**í•  ìˆ˜ ìˆì–´ ë§¤ìš° ì‹¤ìš©ì 

ì£¼ìš” ì§€ì‹œë¬¸:
```c
#pragma omp parallel  // ì½”ì–´ì˜ ìˆ˜ë§Œí¼ ìŠ¤ë ˆë“œ ìƒì„± í›„, ë³‘ë ¬ë¡œ ì‹¤í–‰í•˜ë¼
{
    void update(int value) {
        #pragma omp critical  // Atomically ì‹¤í–‰í•˜ë¼
        {
            count += value;
        }
    }
}
```

* `#pragma omp parallel`: ì‚¬ìš© ê°€ëŠ¥í•œ ì½”ì–´ ìˆ˜ë§Œí¼ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ì—¬ ë³‘ë ¬ë¡œ ì‹¤í–‰
* `#pragma omp critical`: í¬í•¨ëœ ì½”ë“œ ë¸”ë¡ì„ ì„ê³„ ì˜ì—­ìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ ì›ìì ìœ¼ë¡œ ì‹¤í–‰