---
title: "[OS] Operating System(2-2): Design, Implementation, Structure

categories: [CS, Operating System, OS]
tags:
  - [CS, OS, Operating System]
toc: true
toc_sticky: true

date: 2025-03-11
last_modified_at: 2025-03-11
---
>ğŸ€ ìš´ì˜ì²´ì œ ì „ê³µ ìˆ˜ì—… ì •ë¦¬

## Operating system Design and Implementation
---
* OS Design is Not a Simple Problem("**Solvable**")
  * However, some approaches have been successful
* ìš´ì˜ì²´ì œì˜ ë‚´ë¶€ êµ¬ì¡°ëŠ” ë‹¤ì–‘í•¨
  * í•˜ë“œì›¨ì–´ ë° ì‹œìŠ¤í…œ ìœ í˜•ì— ë”°ë¼ ì°¨ì´ê°€ ìˆìŒ
* **Start by Defining Goals and Specifications**
* **OS Goals**: 
  * **<span style="color: #008000">User Goals</span>**: OS should be easy to **use, learn, reliable, safe, fast**
  * **<span style="color: #008000">System Goals</span>**:OS should be easy to **design, implement, maintain, flexible, reliable, error-free, efficient**

?**Key Principle in OS Design**
* **<span style="color: #008000">Policy</span>**: "What will be done?"
* **<span style="color: #008000">Mechanism</span>**: "How to do it?"
* **Mechanism Defines Methods, Policy Determines Decisions**
  * ìš´ì˜ì²´ì œì—ì„œ ì •ì±…ê³¼ ë©”ì»¤ë‹ˆì¦˜ì„ ë¶„ë¦¬í•˜ë©´ ìœ ì—°ì„±ì„ ë†’ì¼ ìˆ˜ ìˆìŒ
* Importance of **Separating Policy & Mechanism**
  * ì •ì±…ì´ ë°”ë€Œì–´ë„ ë©”ì»¤ë‹ˆì¦˜ì„ ìˆ˜ì •í•˜ì§€ ì•Šì•„ë„ ë¨
  * Ex:
    * **Policy**: Limit CPU usage time
    * **Mechanism**: Use a timer to measure execution time
    * CPUë¥¼ ì‹œê°„ ì œí•œì„ ë‘ì§€ ì•Šìœ¼ë©´ ì–´ëŠ í•œ ì‚¬ëŒì´ ë…ì í•´ë²„ë¦¬ëŠ” ë¬¸ì œê°€ ìƒê¸¸ ìˆ˜ ìˆë‹¤ 
    * **ì‹œê°„ ì œí•œì„ ë‘ëŠ” ì›ì¹™ì„ Policy**ë¡œ ì •í–ˆë‹¤ë©´ **ì–´ë–»ê²Œ ë¬´ìŠ¨ ë°©ë²•ìœ¼ë¡œ ì‹œê°„ì„ ì œí•œí•  ê±´ì§€ ì •í•˜ëŠ”ê±´ Mechanism**
* OS Design is a **Highly Creative Software Engineering Task**

### Implement
---
OSëŠ” ë‹¤ì–‘í•œ ì–¸ì–´ë¡œ êµ¬í˜„ë¨
* ì´ˆì°½ê¸°: **assembly language**
* ì´í›„: Algol, PL/1 ë“±ì˜ **system programming languages**
* í˜„ì¬: **C/C++**

OSëŠ” ì¼ë°˜ì ìœ¼ë¡œ **ì—¬ëŸ¬ ì–¸ì–´ì˜ mix**ì„
* **Lowest levels in assembly**
* **Main body in C**
* **Systems programs: C, C++, Python, Perl, Shell Script**

* Higher-Level Languages easier to <u>**port** to other hardware</u>, but **slower**(ì´ì‹ì„±â†‘, ì„±ëŠ¥â†“)
* **Emulation** enables OS to run on Non-Native Hardware(ë¹„ì›ë³¸ í•˜ë“œì›¨ì–´)

## OS Structure
---
**Various ways to structure ones**
* Simple structure ? `MS-DOS`
* More complex ? `UNIX`
* Layered ? `an abstraction`
* Microkernel ? `Mach`

### Monolithic(ë‹¨ì¼) Structure ? Original UNIX
---
ë‹¨ì¼ ê³„ì¸µìœ¼ë¡œ ë˜ì–´ìˆëŠ” ì‹œìŠ¤í…œ
* ë‹¨ì¼ ê³„ì¸µ: **ê³„ì¸µí™”X**, í•œ ê°œì˜ ì¸µì— `file system`, `CPU Scheduling` ë“±ë“± ë‹¤ ë„£ì€ êµ¬ì¡°
* **Limited by hardware functionality** and **had minimal structuring**
* 2ê°€ì§€ ì£¼ìš” êµ¬ì„± ìš”ì†Œ
  * **System Programs**
  * **<span style="color: #008000">The Kernel</span>**:
    * Operates **below the system-call interface** and **above hardware**
    * Provides core OS functionalities(`File System`, `CPU Scheduling`, `Memory Management`)
* **ëª¨ë“  ê¸°ëŠ¥ì´ í•˜ë‚˜ì˜ ë ˆë²¨(one level)ì—ì„œ ìˆ˜í–‰**ë¨(Monolithic Structure)
![alt text](../assets/img/OS/UNIX.png)
>Original UNIX
>ëª¨ë“  ê¸°ëŠ¥ì´ ì»¤ë„ ë‚´ì—ì„œ í•˜ë‚˜ì˜ ë ˆë²¨ë¡œ ì‘ë™í•¨

![alt text](../assets/img/OS/Linux.png)
>ëª¨ë†€ë¦¬ì‹ ì»¤ë„ì´ì§€ë§Œ, ëª¨ë“ˆí™”ë¥¼ í†µí•´ ë³´ë‹¤ ìœ ì—°í•˜ê²Œ ê¸°ëŠ¥ì„ ì¶”ê°€ ë° ì œê±°í•  ìˆ˜ ìˆìŒ

### Layered OS Architecture
---
ğŸ“š The operating system is divided into a number of layers(levels)
* The bottom layer(layer 0) is the **hardware**; the highest (layer N) is the **user interface**

![alt text](../assets/img/OS/Layered_approach.png)
> Layered

* With **modularity**, layers are selected such that each uses functions(operations) and services of **<u>only lower-level layers</u>**
  * ìƒìœ„ ê³„ì¸µì—ì„œ í•˜ìœ„ ê³„ì¸µì„ í˜¸ì¶œí•  ìˆ˜ê°€ ìˆì§€ë§Œ ë°˜ëŒ€ëŠ” ì•ˆ ë¨

### Microkernels
---
* **Moves** as much from the kernel into **<span style="color: #008000">user space</span>**
* **<span style="color: #008000">Mach</span>** example of **microkernel**
  * **Mac OS X kernel(Darwin)** partly based on **Mach**
* **Communication takes place between user modules using message passing**
  * ë³´í†µ ì‚¬ìš©í•˜ëŠ” **monolithic kernelì—ì„œëŠ” APIë¥¼ í†µí•´ì„œ(func call) ì„œë¹„ìŠ¤ë¥¼ ì œê³µ**í•˜ì§€ë§Œ **microkernelì€ message passingì„ í†µí•´ ì œê³µ**í•¨
  * ê·¸ëŸ¼ function callì„ ë‹¨ìˆœíˆ messeage í˜•íƒœë¡œ ë°”ê¾¼ê²Œ ì•„ë‹Œê°€?
  * function callì€ ë™ê¸°ì‹ì´ì§€ë§Œ messeage passingì€ ë™ê¸°ì‹, ë¹„ë™ê¸°ì‹ ë‘˜ë‹¤ ê°€ëŠ¥í•˜ë‹¤
  * ë™ê¸°ì‹ì€ messeageê°€ ì˜¬ ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ì§€ë§Œ ë¹„ë™ê¸°ì‹ì€ ë©”ì„¸ì§€ê°€ ì˜¤ë©´ ë‚˜ì¤‘ì— í™•ì¸í•˜ê³  ê·¸ë•Œ íšŒì‹ í•˜ëŠ” ê°œë…

âœ… **Benefits of Microkernel**  
1. **Easier to extend a microkernel**: ìƒˆë¡œìš´ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ì»¤ë„ì„ ì§ì ‘ ìˆ˜ì •í•˜ì§€ ì•Šê³  ìƒˆë¡œìš´ ì„œë¹„ìŠ¤ ëª¨ë“ˆì„ ì¶”ê°€í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í™•ì¥ ê°€ëŠ¥
2. **Easier to port the operating system to new architectures**: í•˜ë“œì›¨ì–´ ì˜ì¡´ì„±ì´ ë‚®ì•„ ìƒˆë¡œìš´ ì•„í‚¤í…ì²˜(CPU, í•˜ë“œì›¨ì–´)ì— ì‰½ê²Œ port ê°€ëŠ¥
3. **More reliable**: Kernel Modeì—ì„œ ì‹¤í–‰ë˜ëŠ” ì½”ë“œê°€ ì¤„ì–´ë“¤ì–´ ìš´ì˜ì²´ì œê°€ ë”ìš± ì•ˆì •ì 
4. **More secure**

âœ… **Detriments of Microkernel**  
* Performance **overhead of user space to kernel space communication**
  * Microkernelì—ì„œëŠ” ì—¬ëŸ¬ ì‚¬ìš©ì ëª¨ë“ˆ ê°„ `Message Passing` ë°©ì‹ìœ¼ë¡œ í†µì‹ í•´ì•¼ í•˜ë¯€ë¡œ, **ì„±ëŠ¥ ì €í•˜(Overhead)** ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŒ.

![alt text](Microkernel.png)

### Modules
---
* Many modern operating systems implement **<span style="color: #008000">loadable kernel modules(LKMs)</span>**
  * Uses **object-oriented(ê°ì²´ì§€í–¥)** approach
  * Each core component is **separate**
  * Each **communicate to the others over known interfaces**
  * Each is **loadable as needed within the kernel**(í•„ìš”í•  ë•Œë§Œ ë™ì ìœ¼ë¡œ ë¡œë“œ ê°€ëŠ¥)
* Overall, similar to layers but with **more flexibility**
  * Examples: **Linux**, **Solaris**, etc.

### Hybrid Systems
---
* ëŒ€ë¶€ë¶„ì˜ ìµœì‹  ìš´ì˜ì²´ì œëŠ” **ë‹¨ì¼í•œ ìˆœìˆ˜í•œ ëª¨ë¸ì´ ì•„ë‹˜**
* **Hybrid combines multiple approaches** to address performance, security, usability needs
  * **Linux and Solaris kernels**: `Monolithic` + `modular` â†’ **dynamic loading** of functionality(ìƒˆë¡œìš´ ê¸°ëŠ¥ì„ ì‰½ê²Œ ì¶”ê°€ ê°€ëŠ¥)
  * **Windows**: `Monolithic` + `Microkernel` â†’ for different **subsystem personalities**
  * **Apple Mac OS X**: 
    * hybrid, layered, **Aqua** UI plus **Cocoa** programming environment
    * `Mach microkernel` + `BSD Unix` + **I/O kit and dynamically loadable modules(called kernel extensions)**

#### MacOS and iOS Structure
---
![alt text](../assets/img/OS/macOS_iOS.png)
> macOS and iOS Structure

#### Darwin Structure
---
![alt text](../assets/img/OS/Darwin.png)
> Darwin Structure
* **Two System Call Interfaces**
  * **Mach Traps**: Mach ë§ˆì´í¬ë¡œì»¤ë„ì—ì„œ ì œê³µí•˜ëŠ” ì‹œìŠ¤í…œ í˜¸ì¶œ
  * **BSD(POSIX) System Calls**: UNIX/POSIX í‘œì¤€ì„ ì§€ì›í•˜ëŠ” BSD ì»¤ë„ì˜ ì‹œìŠ¤í…œ í˜¸ì¶œ

#### Android 
---
Developed by Open Handset Alliance(**mostly Google**)
* **Open Source**
* Similar stack to iOS
* Based on **Linux kernel but modified**
  * `process`, `memory`, `device-driver management` ì œê³µ
  * Adds power management
* Runtime Environment
  * **í•µì‹¬ ë¼ì´ë¸ŒëŸ¬ë¦¬**ì™€ **ART(Android Runtime) virtual machine** í¬í•¨
  * Appsì€ **Java ë° Android APIë¥¼ ê¸°ë°˜**ìœ¼ë¡œ ê°œë°œë¨
  * **Java class files** â†’ Java bytecode **ë³€í™˜** â†’ **ART VMì—ì„œ ì‹¤í–‰**
* Libraries: `web browser(webkit)`, `database(SQLite)`, `multimedia`, `smaller libc`
* **Dalvik VM**: **JIT(Just-In-Time) Compilation**
* **ART VM**: **AOT(Ahead-Of-Time) Compilation**

![alt text](../assets/img/OS/Android.png)
> Android Structure

* **ART(Android Runtime) VM**: ì•ˆë“œë¡œì´ë“œ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰ í™˜ê²½
* **JNI(Java Native Interface)**: **Java ì½”ë“œê°€ ë„¤ì´í‹°ë¸Œ C/C++ ì½”ë“œì™€ í†µì‹ **í•  ìˆ˜ ìˆë„ë¡ ì§€ì›
* **HAL(Hardware Abstraction Layer)**: Hardwareì™€ Software ì‚¬ì´ì—ì„œ Hardware ê¸°ëŠ¥ì„ ì†Œí”„íŠ¸ì›¨ì–´ì ìœ¼ë¡œ ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ ì§€ì›í•˜ëŠ” ê³„ì¸µ

## System Boot
---
ğŸ“š When power is initialized on the system, execution starts at a **fixed memory location**
* OSëŠ” í•˜ë“œì›¨ì–´ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•˜ë„ë¡ ë¡œë“œë˜ì–´ì•¼ í•¨
âœ… **Booting Process**  
1. **<span style="color: #008000">BIOS / UEFI ì‹¤í–‰ (Executing BIOS / UEFI)</span>**
   * `Small piece of code`ê°€ **ROM** or **EEPROM**ì— ì €ì¥ë¨
   * ì´ë¥¼ í†µí•´ **ì»¤ë„ì„ ì°¾ê³ **, **ë©”ëª¨ë¦¬ì— ë¡œë“œ í›„ ì‹¤í–‰**
   * Modern systems replace BIOS with **UEFI (Unified Extensible Firmware Interface)**
2. **<span style="color: #008000">Boot Block í™œìš© (Optional Two-step Process)</span>**
   * **Boot Block**ì´ **ROM ì½”ë“œ**ì— ì˜í•´ ì‹¤í–‰ë¨
   * Boot Blockì´ ë””ìŠ¤í¬ì—ì„œ **bootstrap loader**ë¥¼ ë¡œë“œí•˜ì—¬ ì‹¤í–‰
3. **<span style="color: #008000">Bootloader Execution - GRUB ì‚¬ìš©</span>**
   * **GRUB (Grand Unified Bootloader)**ë¥¼ í†µí•´ ì—¬ëŸ¬ OS ì»¤ë„ì„ ì„ íƒ ê°€ëŠ¥
4. **<span style="color: #008000">Kernel Loads and System Running</span>**

* **GRUB(Grand Unified Bootloader)** ì—­í• 
  * GRUBëŠ” Linuxì—ì„œ ì£¼ë¡œ ì‚¬ìš©ë˜ë©°, ë‹¤ì–‘í•œ ë¶€íŒ… ì˜µì…˜ì„ ì§€ì›
  * ë¶€íŒ… ì‹œ ì‚¬ìš©ìê°€ ì›í•˜ëŠ” ì»¤ë„ì„ ì„ íƒ ê°€ëŠ¥
  * GRUBëŠ” **open source**ë¡œ ê°œë°œë¨

## Operating System Debugging
---
ğŸ“š **<span style="color: #008000">Debugging</span> is finding and fixing errors, or bugs**
* OS generate **log files** containing **error information**
* **Core Dump & Crash Dump**
  * **Core Dumpì™€ Crash Dump**ëŠ” í”„ë¡œê·¸ë¨ ë° OS ì˜¤ë¥˜ ë°œìƒ ì‹œ í•„ìˆ˜ì ì¸ **ë””ë²„ê¹… ë„êµ¬** 
  * **Core Dump**: í”„ë¡œê·¸ë¨ì´ ë¹„ì •ìƒì ìœ¼ë¡œ ì¢…ë£Œë  ë•Œ, **<u>í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬ ìƒíƒœ</u>ë¥¼ ì €ì¥í•œ íŒŒì¼**
  * **Crash Dump**: ìš´ì˜ì²´ì œê°€ ë¹„ì •ìƒì ìœ¼ë¡œ ì¢…ë£Œë  ë•Œ, **<u>ì»¤ë„ ë©”ëª¨ë¦¬ ìƒíƒœ</u>ë¥¼ ì €ì¥í•œ íŒŒì¼**

* **Performance Tuning(ì„±ëŠ¥ ìµœì í™”)**
  * **Trace Listings(ì¶”ì  ëª©ë¡)**: **í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì¤‘ì˜ í™œë™ì„ ê¸°ë¡**í•˜ì—¬ ë¶„ì„í•˜ëŠ” ê¸°ë²•
  * **Profiling**: **ì£¼ê¸°ì ìœ¼ë¡œ Instruction Pointerë¥¼ ìƒ˜í”Œë§**í•˜ì—¬ ì„±ëŠ¥ ë¶„ì„
  * Improve performance by removing **bottlenecks(ë³‘ëª© í˜„ìƒ)**
  * OS must **provide means of computing and displaying measures of system behavior**
    * For example, **â€œtopâ€ program(Linux)** or **Windows Task Manager**

* **Kernighan's Law**
  * "ë””ë²„ê¹…ì€ ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ” ê²ƒë³´ë‹¤ ë‘ ë°° ë” ì–´ë µë‹¤"
  * "ì½”ë“œë¥¼ ê°€ëŠ¥í•œ í•œ ìŠ¤ë§ˆíŠ¸í•˜ê²Œ ì‘ì„±í–ˆë‹¤ë©´, ë””ë²„ê¹…ì„ í•  ë§Œí¼ ë˜‘ë˜‘í•˜ì§€ ì•Šì„ ê°€ëŠ¥ì„±ì´ ë†’ë‹¤"
  * ì¦‰, ì§€ë‚˜ì¹˜ê²Œ ë³µì¡í•œ ì½”ë“œë¥¼ ì‘ì„±í•˜ë©´ ë””ë²„ê¹…ì´ ì–´ë ¤ì›Œì§„ë‹¤ëŠ” ì˜ë¯¸!!

### Tracing
---
* **Tracing**: Collects data for a specific event, such as steps involved in a system call invocation  
  â†’ **ì‹œìŠ¤í…œì´ ì–´ë–¤ ìˆœì„œë¡œ ì–´ë–¤ ìì›ì— ì ‘ê·¼í•˜ëŠ”ì§€ ì¶”ì  ê°€ëŠ¥**

  * ëŒ€í‘œì ì¸ íŠ¸ë ˆì´ì‹± ë„êµ¬ë“¤
    * `strace`: íŠ¹ì • **í”„ë¡œì„¸ìŠ¤ê°€ í˜¸ì¶œí•˜ëŠ” system call**ì„ ì¶”ì í•¨ (ex: íŒŒì¼ ì—´ê¸°, ì½ê¸°, ì“°ê¸° ë“±)
    * `gdb`: GNU Debugger. **ì†ŒìŠ¤ ì½”ë“œ ë‹¨ìœ„ì˜ ë””ë²„ê¹… ë„êµ¬** (breakpoint ì„¤ì •, ë³€ìˆ˜ í™•ì¸ ë“±)
    * `perf`: **Linux ë‚´ì¥ ì„±ëŠ¥ ë¶„ì„ íˆ´ ëª¨ìŒ**. CPU ì‚¬ìš©ëŸ‰, ìºì‹œ ë¯¸ìŠ¤ ë“± í•˜ë“œì›¨ì–´ ì„±ëŠ¥ë„ ì¶”ì  ê°€ëŠ¥
    * `tcpdump`: **collects network packets**

### BCC
---
`user-level code`ì™€ `kernel code` ì‚¬ì´ì˜ ìƒí˜¸ì‘ìš©ì„ **debugging**í•˜ëŠ” ê²ƒì€ ì´ë¥¼ ëª¨ë‘ ì´í•´í•˜ê³  ë¶„ì„í•  ìˆ˜ ìˆëŠ” **toolset** ì—†ì´ëŠ” ê±°ì˜ ë¶ˆê°€ëŠ¥í•¨

ğŸ“š**BCC = BPF Compiler Collection**: **ë¦¬ëˆ…ìŠ¤ë¥¼ ìœ„í•œ ê°•ë ¥í•œ íŠ¸ë ˆì´ì‹± ë„êµ¬ ëª¨ìŒ**
  * ê¸°ë°˜ ê¸°ìˆ ì€ eBPF (Extended Berkeley Packet Filter)
![alt text](../assets/img/OS/BCC.png)
> disk I/O í™œë™ ì¶”ì  ë„êµ¬

![alt text](../assets/img/OS/more_BCC.png)
> Linux bcc/BPF Tracing Tools