---
title: "[🌐CN] Internet Protocol(3) - IP Header & Forwarding"

categories: [CS, Internet Protocol]
tags:
  - [CS, Internet Protocol, Computer Networking, Network layer, IP, Fragmentation, MTU, Routing, Forwarding]
toc: true
toc_sticky: true

date: 2025-09-22
last_modified_at: 2025-09-22
---
>🌐 Internet Protocol 전공 수업 정리

*IP는 인터넷의 허리(waist of the hourglass)라 불린다. 모든 상위 레이어 프로토콜과 하위 레이어 기술들이 IP를 중심으로 연결되기 때문이다. IP의 구조, 헤더 필드, 그리고 포워딩 메커니즘을 깊이 있게 살펴보자.*

-----

## **IP의 역할과 위치**

### The Waist of the Hourglass

📚**<span style="color: #008000">IP (Internet Protocol)</span>**: Network Layer에서 동작하는 프로토콜로, 다양한 링크 계층 기술들과 상위 전송 계층 프로토콜들을 연결하는 핵심 프로토콜

**모래시계 모델:**

```
                    Application Layer
                 ┌──────────────────────┐
                 │ HTTP  SMTP  RTP ...  │  ← 다양한 상위 프로토콜
                 └──────────┬───────────┘
                 ┌──────────▼───────────┐
                 │   TCP      UDP       │
                 └──────────┬───────────┘
                      ┌─────▼─────┐
                      │    IP     │        ← 허리 (Waist)!
                      └─────┬─────┘
                 ┌──────────▼───────────┐
                 │ Ethernet  WiFi  PPP  │  ← 다양한 하위 기술
                 │ FDDI  ATM  Bluetooth │
                 └──────────────────────┘
                    Physical Layer
```

**핵심 특징:**
* ✅ **One network layer protocol**: 모든 인터넷 연결 장치에 구현되어야 함
* ✅ **호환성 해결**: 서로 다른 링크 계층 기술들 간의 호환성 문제 해결
* ✅ **IP Forwarding**: 패킷을 목적지까지 전달하는 핵심 기능

### IP가 구현되는 위치

```
Host A           Router 1         Router 2         Host B
┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│   App    │    │          │    │          │    │   App    │
├──────────┤    ├──────────┤    ├──────────┤    ├──────────┤
│   TCP    │    │          │    │          │    │   TCP    │
├──────────┤    ├──────────┤    ├──────────┤    ├──────────┤
│    IP    │◄──►│    IP    │◄──►│    IP    │◄──►│    IP    │
├──────────┤    ├──┬────┬──┤    ├──┬────┬──┤    ├──────────┤
│ Data Link│    │DL│ DL │DL│    │DL│ DL │DL│    │Data Link │
└──────────┘    └──┴────┴──┘    └──┴────┴──┘    └──────────┘
```

**중요 포인트:**
* **IP는 라우터와 호스트 모두에서 구현되는 최상위 프로토콜**
* Application과 TCP는 End-to-End (호스트에서만)
* IP는 hop-by-hop (모든 라우터에서 처리)

-----

## **IP Service 특성**

### IP의 3가지 핵심 특성

**1️⃣ Connectionless (비연결성)**
* 📌 **물리적인 연결이 없다는 의미가 아님** → 관리 없음
* 각 패킷이 독립적으로 처리됨
* 순차적 전달 보장 없음 (No sequential delivery)

**2️⃣ Unreliable (비신뢰성)**
* 패킷 손실 가능 (Lost packets)
* 중복 패킷 발생 가능
* 순서 뒤바뀜 가능 (Out-of-sequence delivery)

**3️⃣ Best Effort (최선 노력)**
* Throughput 보장 없음
* Delay 보장 없음
* QoS 보장 없음

**결과:**

```
Consequences:
┌────────────────────────────────────────────────────┐
│ ❌ 패킷이 순서대로 도착하지 않을 수 있음             │
│ ❌ 패킷이 손실되거나 중복될 수 있음                 │
│ ✅ 상위 계층 프로토콜(TCP)이 이를 처리해야 함       │
└────────────────────────────────────────────────────┘
```

{:.prompt-info}
> **Why Best Effort?**: 단순성과 확장성을 위해 복잡한 보장 기능은 상위 계층(TCP)에 위임

### IP가 지원하는 통신 방식

📚**<span style="color: #008000">IP Multicast</span>**: 하나의 패킷을 여러 수신자에게 전송하는 효율적인 방법 (IGMP, multicast routing 프로토콜 필요)

**3가지 통신 방식:**

```
1. Unicast (1:1)          2. Broadcast (1:all)       3. Multicast (1:some)
     ●  →  ●                    ●  →  ●●●                  ●  →  ●●
                                      ●●●                        ●
```

| 방식          | 설명                    | 예시               |
| :------------ | :---------------------- | :----------------- |
| **Unicast**   | 1:1 통신                | 일반 웹 브라우징   |
| **Broadcast** | 1:모두 통신             | ARP request        |
| **Multicast** | 1:그룹 통신 (선택적)    | IPTV, 화상회의     |

-----

## **IP Header 구조**

### IP Header 전체 구조

```
bit # 0       7 8      15 16     23 24                            31
├──────┬───────┼─────────┼─────────┼──────────────────────────────┤
│version│header│   DS   │   ECN   │    total length (in bytes)   │
│  (4) │length│   (6)  │   (2)   │           (16 bits)          │
├──────┴───────┴────────┴──────┬──┼──┬───┬───────────────────────┤
│       Identification          │0 │DF │MF │  Fragment offset    │
│          (16 bits)            │  │ (1)│(1)│    (13 bits)        │
├───────────────┬───────────────┴──┴───┴───┴───────────────────────┤
│time-to-live   │   protocol    │    header checksum              │
│   (TTL)       │    (8 bits)   │      (16 bits)                  │
│  (8 bits)     │               │                                 │
├───────────────┴───────────────┴──────────────────────────────────┤
│                  source IP address (32 bits)                    │
├───────────────────────────────────────────────────────────────────┤
│                destination IP address (32 bits)                 │
├───────────────────────────────────────────────────────────────────┤
│                  options (0 to 40 bytes)                        │
├───────────────────────────────────────────────────────────────────┤
│                       payload                                   │
└───────────────────────────────────────────────────────────────────┘
                        4 bytes
```

**크기:**
* **최소 헤더 크기**: 20 bytes (옵션 없을 때)
* **최대 헤더 크기**: 60 bytes (옵션 40 bytes 포함)
* **최대 Total Length**: 2^16 bytes = 65,536 bytes

-----

## **IP Header 필드 상세**

### Version (4 bits)

**역할**: IP 프로토콜 버전 식별

* **IPv4**: 값 = `4` (대부분)
* **IPv6**: 값 = `6`

### Header Length (4 bits)

📚**<span style="color: #008000">Header Length (IHL)</span>**: IP 헤더의 길이를 4-byte 단위로 표현

**계산 방법:**
```
헤더 길이 = Header Length × 4 bytes

예시:
  Header Length = 5 → 5 × 4 = 20 bytes (옵션 없음)
  Header Length = 15 → 15 × 4 = 60 bytes (최대)
```

### DS/ECN Field (1 byte = 8 bits)

**과거: Type of Service (TOS) 필드**
**현재: DS (6 bits) + ECN (2 bits)**

**Differentiated Service (DS) - 6 bits:**
* 서비스 레벨 지정 (현재 인터넷에서는 미지원)
* QoS 차별화 용도

**Explicit Congestion Notification (ECN) - 2 bits:**
* TCP의 혼잡 제어를 위한 피드백 메커니즘
* 라우터가 혼잡 상태를 패킷에 표시

### Total Length (16 bits)

**역할**: 전체 패킷 크기 (헤더 + 페이로드)

```
Total Length = IP Header + IP Payload
최소: 20 bytes (헤더만)
최대: 65,535 bytes (2^16 - 1)

⚠️ 주의: 하위 링크 계층의 MTU가 이보다 작을 수 있음!
```

-----

## **Fragmentation 관련 필드**

### MTU (Maximum Transmission Unit)

📚**<span style="color: #008000">MTU</span>**: 데이터 링크 프로토콜이 전송할 수 있는 최대 IP 패킷 크기

**주요 MTU 값:**

| 링크 타입   | MTU (bytes) |
| :---------- | :---------- |
| **Ethernet**| 1,500       |
| **802.3**   | 1,492       |
| **802.5**   | 4,464       |
| **FDDI**    | 4,352       |
| **ATM AAL5**| 9,180       |
| **PPP**     | negotiated  |

**문제 상황:**

```
Host A                 Router              Host B
  │                      │                    │
  │  4,000 byte packet   │                    │
  ├──────────────────────►                    │
         FDDI MTU=4352   │  Ethernet MTU=1500 │
                         │                    │
                    Fragmentation 필요!
```

### Fragmentation (단편화)

**Fragmentation이 발생하는 경우:**
* IP datagram 크기 > 링크의 MTU
* 라우터가 패킷을 여러 조각(fragment)으로 분할

**Fragmentation 장소:**
* Sender (송신자)
* Intermediate routers (중간 라우터)
* 동일한 datagram이 여러 번 fragmentation될 수 있음

### Reassembly (재조립)

**어디서 재조립하는가?**

**❌ Option 1: 중간 라우터에서 재조립?**

```
Host A  →  R1  →  R2  →  Host B
       Fragment  Reassemble?
```

* **문제**: Fragment들이 서로 다른 경로로 갈 수 있음!

**✅ Option 2: 최종 목적지(End-host)에서 재조립**

```
Host A  →  R1  ┬→  R3  ┐
              Fragment  └→  Host B (Reassemble!)
           R2  ┘
```

* **정답**: 모든 fragment는 **최종 수신자(Destination host)**에서 재조립
* Fragments가 서로 다른 경로를 거칠 수 있기 때문!

### Fragmentation 관련 필드

**Identification (16 bits):**
* 동일한 datagram의 모든 fragment는 **동일한 ID**
* 송신자가 datagram 전송 시마다 증가시킴

**Flags (3 bits):**

| 비트 | 이름 | 의미                                    |
| :--- | :--- | :-------------------------------------- |
| 0    | -    | 항상 0 (예약)                           |
| DF   | Don't Fragment | 1이면 단편화 금지, 패킷 drop 후 ICMP 전송 |
| MF   | More Fragments | 1이면 뒤에 fragment가 더 있음           |

**Fragment Offset (13 bits):**
* 현재 fragment의 페이로드가 원본 datagram에서 차지하는 위치
* **8-byte 단위로 표현** (실제 offset = 값 × 8)

### Fragmentation 예시

**Original Packet: 4,000 bytes**

```
Version: 4          Header Length: 5        Type of Service: 0
Total Length: 4000
Identification: 56273                    R/D/M: 0/0/0
Fragment Offset: 0
TTL: 127            Protocol: 6 (TCP)     Checksum: 44019
Source: 1.2.3.4
Destination: 3.4.5.6
(3980 bytes payload)
```

**MTU = 1,500 bytes일 때 Fragmentation:**

```
원본:
┌────┬──────────────────────────────────────┐
│ 20 │           3980 bytes                 │
└────┴──────────────────────────────────────┘
     4000 bytes

분할 후:
┌────┬───────────────┐  ┌────┬──────────┐  ┌────┬──────────┐
│ 20 │  1480 bytes   │  │ 20 │ 1200     │  │ 20 │ 1300     │
└────┴───────────────┘  └────┴──────────┘  └────┴──────────┘
     1500 bytes              1220 bytes         1320 bytes
```

**Fragment 1:**
```
Total Length: 1500
Identification: 56273
R/D/MF: 0/0/1  ← MF=1 (더 있음!)
Fragment Offset: 0  (0 × 8 = 0)
```

**Fragment 2:**
```
Total Length: 1220
Identification: 56273
R/D/MF: 0/0/1  ← MF=1 (더 있음!)
Fragment Offset: 185  (185 × 8 = 1480)
```

**Fragment 3 (마지막):**
```
Total Length: 1320
Identification: 56273
R/D/MF: 0/0/0  ← MF=0 (마지막!)
Fragment Offset: 335  (335 × 8 = 2680)
```

-----

## **TTL (Time-to-Live)**

### TTL의 역할

📚**<span style="color: #008000">TTL (Time-to-Live)</span>**: 패킷이 무한 루프를 도는 것을 방지하기 위한 홉 카운터

**문제 상황: Forwarding Loop**

```
     R1 ⇄ R2
      ↓   ↑
      R3

패킷이 무한정 순환! → 모든 대역폭 소모!
```

**TTL 동작 방식:**

1. **Sender**: TTL 값 설정 (예: 64)
2. **각 라우터**: TTL 값을 1씩 감소
3. **TTL = 0**: Datagram drop + "Time Exceeded" ICMP 메시지 송신

**Ping 출력 예시:**

```bash
C:\Users\사용자>ping www.unipi.it

131.114.21.42의 응답: 바이트=32 시간=308ms TTL=39
131.114.21.42의 응답: 바이트=32 시간=307ms TTL=39
131.114.21.42의 응답: 바이트=32 시간=306ms TTL=39
```

**TTL 값의 의미:**
* 초기값 64로 시작했다면 → 25 hops (64 - 39 = 25)
* traceroute의 기반이 되는 메커니즘!

-----

## **Protocol Field**

### Protocol (8 bits)

📚**<span style="color: #008000">Protocol Field</span>**: 상위 계층 프로토콜을 식별하여 수신 호스트가 올바르게 역다중화(demultiplexing)할 수 있도록 함

**주요 Protocol 번호:**

| 번호 | 프로토콜           | 설명                     |
| :--- | :----------------- | :----------------------- |
| 1    | **ICMP**           | Internet Control Message |
| 2    | **IGMP**           | Internet Group Management|
| 4    | **IP-in-IP**       | IP encapsulation         |
| 6    | **TCP**            | Transmission Control     |
| 17   | **UDP**            | User Datagram            |

**Demultiplexing 예시:**

```
수신 패킷:
  Protocol = 6 (TCP)
     ↓
  IP 계층이 TCP 모듈로 전달
     ↓
  TCP 헤더 파싱 시작
```

-----

## **Header Checksum**

### Checksum (16 bits)

📚**<span style="color: #008000">Header Checksum</span>**: IP 헤더의 무결성을 검증하기 위한 체크섬 (payload는 검사 안 함!)

**계산 방법: One's Complement Sum**

```
Step 1: 16-bit words로 분할
  1011 0000 0101 1111  +
  1110 1100 0101 1100  =
 ───────────────────────
 1 1001 1100 1011 1011  ← Carry 발생

Step 2: Carry를 다시 더함
  1001 1100 1011 1011  +
  0000 0000 0000 0001  =
 ───────────────────────
  1001 1100 1011 1100

Step 3: One's Complement (비트 반전)
  0110 0011 0100 0011  ← Checksum!
```

**매 라우터에서 재계산:**
* TTL이 변경되므로 checksum도 매번 재계산 필요
* Checksum 불일치 → 패킷 폐기

**Checksum Offloading:**
* 성능 향상을 위해 NIC (Network Interface Card)에서 계산
* OS 부담 감소

-----

## **IP Options**

### Options (0~40 bytes)

📚**<span style="color: #008000">IP Options</span>**: 선택적으로 사용 가능한 확장 기능 (TLV 형식)

**TLV (Type-Length-Value) 구조:**

```
┌──────┬────────┬────────────────┐
│ Type │ Length │     Value      │
└──────┴────────┴────────────────┘
  1 byte  1 byte   Variable
```

**주요 Option들:**

| Type | 이름             | 설명                                          | 사용 빈도  |
| :--- | :--------------- | :-------------------------------------------- | :--------- |
| 0    | End of List      | 옵션 목록 끝                                  | If required|
| 1    | No Operation     | Padding 용도                                  | If required|
| 7    | **Record Route** | 각 라우터가 자신의 IP를 헤더에 추가           | Rare       |
| 68   | **Timestamp**    | 각 라우터가 IP + 시간 추가                     | Rare       |
| 131  | **Loose Source Routing** | 반드시 거쳐야 할 라우터 목록 (중간에 다른 라우터 가능) | Rare, filtered |
| 137  | **Strict Source Routing**| 오직 명시된 라우터들만 거쳐야 함               | Rare, filtered |
| 148  | **Router Alert** | 라우터가 패킷 내용을 검사해야 함               | Occasional |

### Router Alert Option

**특징:**
* 보통 라우터는 패킷을 포워딩만 함
* **Router Alert**: 라우터가 패킷 내용을 검사하고 특별한 처리 수행

**사용 예시: IGMP (Internet Group Management Protocol)**

```
┌─────────────────────────────────────────────────┐
│ Options: (4 bytes), Router Alert               │
│   Router Alert (4 bytes): Router shall examine  │
│     Type: 148                                   │
│     Length: 4                                   │
│     Router Alert (20)                           │
├─────────────────────────────────────────────────┤
│ Internet Group Management Protocol              │
│   [IGMP Version: 2]                             │
│   Type: Membership Query (0x11)                 │
│   Max Response Time: 10.0 sec (0x64)            │
└─────────────────────────────────────────────────┘
```

**라우터에게 상태 정보(state)가 기록되어야 할 때 RA 옵션 사용**
→ 악의적으로 사용 가능 (공격 벡터)

### Source Routing

**Loose Source Routing (Type 131):**

```
Wireshark 예시:
Source Route: 151.101.229.67 <- (next)
Destination: 151.101.229.67

Time to live: 1
Current Route: 163.152.1.1
```

* 패킷이 특정 라우터들을 **반드시 거쳐야 함**
* 중간에 다른 라우터도 거칠 수 있음

**보안 이슈:**
* 대부분의 라우터는 **source routing 옵션을 drop**함
* 해킹에 악용될 수 있기 때문

### Padding

**역할**: IP 헤더가 **4-byte 경계**에서 끝나도록 보장

```
Options: 11 bytes
Padding: 1 byte 추가
Total Header: 20 + 12 = 32 bytes (4의 배수 ✅)
```

-----

## **IP 공격 유형**

### Attacks Involving IP

**1. IP 헤더 필드 조작:**
* Bad header length
* Wrong version number
* 목표: 라우터 크래시 또는 성능 저하

**2. Option 악용:**
* Specialized code (fragment reassembly) 버그 익스플로잇
* Router Alert 남용

**3. IP Spoofing:**

📚**<span style="color: #008000">IP Spoofing</span>**: 송신자가 Source IP 주소를 위조하여 공격

**방어: Ingress Filtering**
```
ISP 경계 라우터에서:
  ┌────────────────────────────┐
  │ If (source IP prefix !=    │
  │     expected prefix)       │
  │   → DROP packet!           │
  └────────────────────────────┘
```

* 라우터가 들어오는 패킷의 **Source IP prefix 검증**
* 예상되는 prefix가 아니면 폐기

-----

## **Forwarding (포워딩)**

### Forwarding의 개념

📚**<span style="color: #008000">Forwarding</span>**: 라우터가 수신한 패킷을 적절한 출력 인터페이스로 전달하는 과정

**라우터의 주요 기능:**
1. **Routing**: 경로 결정 (Routing Table 생성)
2. **Forwarding**: 실제 패킷 전달 (Forwarding Table 사용)

### Routing Table 구조

**IPv4 Routing Table:**

```
활성 경로:
┌──────────────┬──────────────┬─────────────┬──────────────┬────────┐
│네트워크 대상 │네트워크마스크│ 게이트웨이  │ 인터페이스   │메트릭  │
├──────────────┼──────────────┼─────────────┼──────────────┼────────┤
│  0.0.0.0     │  0.0.0.0     │ 192.168.0.1 │ 192.168.0.33 │   50   │
│ 127.0.0.0    │ 255.0.0.0    │  연결됨     │ 127.0.0.1    │  331   │
│ 127.0.0.1    │255.255.255.255│ 연결됨     │ 127.0.0.1    │  331   │
│127.255.255.255│255.255.255.255│연결됨     │ 127.0.0.1    │  331   │
│ 192.168.0.0  │255.255.255.0 │  연결됨     │192.168.0.33  │  306   │
│192.168.0.33  │255.255.255.255│ 연결됨     │192.168.0.33  │  306   │
│192.168.0.255 │255.255.255.255│ 연결됨     │192.168.0.33  │  306   │
│ 224.0.0.0    │ 240.0.0.0    │  연결됨     │ 127.0.0.1    │  331   │
│ 224.0.0.0    │ 240.0.0.0    │  연결됨     │192.168.0.33  │  306   │
│255.255.255.255│255.255.255.255│연결됨     │ 127.0.0.1    │  331   │
│255.255.255.255│255.255.255.255│연결됨     │192.168.0.33  │  306   │
└──────────────┴──────────────┴─────────────┴──────────────┴────────┘
```

**구성 요소:**

1. **Destination network prefix** (네트워크 대상)
2. **Network mask** (네트워크 마스크)
3. **Gateway** (게이트웨이): 다음 홉 라우터의 IP 주소 (또는 "연결됨")
4. **Interface** (인터페이스): 패킷을 내보내는 IF
5. **Metric** (메트릭): 엔트리 우선순위 (낮을수록 우선)

### Default Router vs Core Router

**Default Router (Edge Router):**

```
┌────────────────────────────┐
│  Default Entry 있음        │
│  0.0.0.0/0 → Gateway       │
└────────────────────────────┘
       │
   매칭 안되면?
       │
   ┌───▼───┐
   │Internet│
   │내부로  │
   │forward │
   └───────┘
```

* **Default entry (0.0.0.0/0)** 존재
* 알지 못하는 네트워크를 인터넷으로 전달

**Core Router (Backbone Router):**

```
┌────────────────────────────┐
│  No Default Entry!         │
│  완전한 Routing Table      │
│  (~800,000 entries)        │
└────────────────────────────┘
       │
   매칭 안되면?
       │
   ┌───▼───┐
   │ DROP! │
   └───────┘
```

* Default entry **없음**
* 전 세계 모든 네트워크 정보 보유 (~80만 개 엔트리)
* 매칭 안 되면 → 존재하지 않는 주소!

### ARP Cache

**ARP Cache의 역할:**
* IP 주소 → MAC 주소 매핑 정보 저장
* Forwarding 시 Next-hop의 MAC 주소 조회

```bash
C:\Users\사용자>arp -a

인터페이스: 172.30.1.59 --- 0x14
  인터넷 주소       물리적 주소           유형
  172.30.1.37     44-cb-8b-e4-01-64     동적
  172.30.1.43     48-e2-44-27-c7-21     동적
  172.30.1.128    90-f8-91-89-ba-6a     동적
  172.30.1.254    00-07-89-82-0d-aa     동적
  172.30.1.255    ff-ff-ff-ff-ff-ff     정적
  224.0.0.2       01-00-5e-00-00-02     정적
  ...
```

### Routing Table Update

**라우팅 테이블 갱신 방법:**

1. **Routing Protocol** (자동):
   * RIP, OSPF, BGP 등
   * 동적으로 경로 학습

2. **OS** (자동):
   * 인터페이스 up/down 감지
   * 직접 연결된 네트워크 추가/삭제

3. **Admin (수동)**:
   * Static route 추가
   * 관리자가 직접 설정

-----

## **Forwarding 예시**

### 네트워크 구성

```
                   166.140.21.23/24 (Ethernet)
                        │
       166.140.21.49/28─┼─166.140.21.3/28
                        │
          ┌─────────────▼─────────────┐
          │        Router              │
          │                            │
          └─┬──────────────────────┬───┘
            │ PPP                  │ Ethernet
   166.140.21.50/28                │
            │                      │
   166.140.21.67/28        166.140.21.0/28
            │                      │
        ┌───▼──┐              ┌────┴────┐
        │Router│              │ Hosts   │
        └──────┘              └─────────┘
   166.140.21.77/28
```

**Routing Table:**

| Destination      | Next hop       | Netmask       | Interface |
| :--------------- | :------------- | :------------ | :-------- |
| 166.140.21.0     |                |               | eth0      |
| 127.0.0.0        | 127.0.0.1      | 255.0.0.0     | lo0       |
| 166.140.21.50    |                |               | ppp0      |
|                  |                |               | ppp1      |
| 0.0.0.0          | 166.140.21.1   |               | eth1      |

**포워딩 결정:**

```
패킷 도착: Destination = 166.140.21.5

Step 1: Routing Table 조회
  - 166.140.21.0 매치! (eth0)

Step 2: ARP Cache 조회
  - 166.140.21.5의 MAC 주소?

Step 3: 패킷 전송
  - Ethernet frame으로 캡슐화
  - eth0 인터페이스로 송출
```

-----

## **정리**

### IP의 핵심 특징 요약

| 특징             | 설명                                    |
| :--------------- | :-------------------------------------- |
| **Connectionless**| 패킷마다 독립적 처리                    |
| **Unreliable**   | 손실, 중복, 순서 뒤바뀜 가능            |
| **Best Effort**  | QoS 보장 없음                           |
| **Hourglass**    | 모든 네트워크 기술의 공통 인터페이스    |

### IP Header의 중요 필드

| 필드                 | 역할                           | 크기     |
| :------------------- | :----------------------------- | :------- |
| **Version**          | IPv4 vs IPv6                   | 4 bits   |
| **Total Length**     | 패킷 전체 크기                 | 16 bits  |
| **Identification**   | Fragment 식별                  | 16 bits  |
| **Flags & Offset**   | Fragmentation 제어             | 16 bits  |
| **TTL**              | 무한 루프 방지                 | 8 bits   |
| **Protocol**         | 상위 프로토콜 식별 (TCP/UDP)   | 8 bits   |
| **Checksum**         | 헤더 무결성 검증               | 16 bits  |
| **Source/Dest IP**   | 송수신자 주소                  | 32 bits  |

{:.prompt-tip}
> **Forwarding의 핵심**: Routing Table의 Longest Prefix Matching으로 Next-hop 결정! 


