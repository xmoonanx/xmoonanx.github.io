---
title: "[CA] Chapter 3-1: Logical Operations"

categories: [CS, Computer Architecture, CA, Assembly language]
tags:
  - [CS, c, cpp, Computer Architecture, CA, Assembly language, binary code]
toc: true
toc_sticky: true

date: 2025-03-31
last_modified_at: 2025-03-31
---
âš™ **Computer Architecture ê³µë¶€**

## Logical Operations
---
### Shift Operations
---
ğŸ“š **<span style="color: #008000">Shifting</span>** all the bits in a word to **the left or right**, with the emptied bits **filled with 0s**
**Shift instruction**:
* `sll(Shift Left Logical)`: bitsë¥¼ ì™¼ìª½ìœ¼ë¡œ ì´ë™
* `srl(Shift Right Logical)`: bitsë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™

**ì˜ˆì‹œ**:
1. ê°’ 9ë¥¼ 4bitsë§Œí¼ shiftí•˜ëŠ” ê²½ìš°:

* 9 = 0000 0000 0000 0000 0000 0000 0000 1001
* **(Shifting left)** `9 << 4` = 0000 0000 0000 0000 0000 0000 1001 0000 = 144 (10ì§„ìˆ˜)
* **(Shifting right)** `9 >> 4` = 0000 0000 0000 0000 0000 0000 0000 0000  = 0 (10ì§„ìˆ˜)

2. `sll $t2, $s0, 4`  # $t2 = $s0 << 4ë¹„íŠ¸
* `op` = 0 (R-type)
* `rs` = 0 (ë¯¸ì‚¬ìš©)
* `rt` = 10000 ($s0=16)
* `rd` = 01010 ($t2=10)
* `shamt` = 00100 (shift bits=4)
* `funct` = 0 (sll ì—°ì‚°)

### And/Or Operations
---
`AND operation`ì€ **ë‘ ë¹„íŠ¸ê°€ ëª¨ë‘ 1ì¸ ê²½ìš°ì—ë§Œ ê²°ê³¼ê°€ 1ì´ ë˜ëŠ”** ì—°ì‚°
`OR operation`ì€ **ë‘ ë¹„íŠ¸ ì¤‘ í•˜ë‚˜ë¼ë„ 1ì´ë©´ ê²°ê³¼ê°€ 1ì´ ë˜ëŠ”** ì—°ì‚°

* and/or ì˜ˆì‹œ:
  * `$t1` = 0000 0000 0000 0000 0011 1100 0000 0000 = 15,360 (demical)
  * `$t2` = 0000 0000 0000 0000 0000 1101 1100 0000 = 3,520 (demical)

```
and $t0, $t1, $t2  # $t0 = $t1 & $t2
```  
* `$t0` = 0000 0000 0000 0000 0000 1100 0000 0000 = 3,072 (demical)

```
or $t0, $t1, $t2  # $t0 = $t1 | $t2
```
* `$t0` = 0000 0000 0000 0000 0011 1101 1100 0000 = 15,808 (demical)

MIPSëŠ” ANDì™€ OR operationì˜ `immediate` ë²„ì „ë„ ì§€ì›
* `andi` (AND immediate): ë ˆì§€ìŠ¤í„°ì™€ ì¦‰ì‹œê°’ ì‚¬ì´ì˜ AND ì—°ì‚°
* `ori` (OR immediate): ë ˆì§€ìŠ¤í„°ì™€ ì¦‰ì‹œê°’ ì‚¬ì´ì˜ OR ì—°ì‚°

### NOR Operation
---
`NOR operation`ì€ **ë‘ ë¹„íŠ¸ë¥¼ OR ì—°ì‚°í•œ í›„ ê·¸ ê²°ê³¼ë¥¼ ë°˜ì „(NOT)ì‹œí‚¤ëŠ” ì—°ì‚°**

* ì˜ˆì‹œ:
```
nor $t0, $t1, $t3  # $t0 = ~($t1 | $t3)
```
* `$t1` = 0000 0000 0000 0000 0011 1100 0000 0000 = 15,360 (demical)
* `$t3` = 0000 0000 0000 0000 0000 0000 0000 0000 = 0 (demical)
* `$t1` or `$t3` = 0000 0000 0000 0000 0011 1100 0000 0000 = 0 (demical)
* NOT(`$t1` or `$t3`) = 1111 1111 1111 1111 1100 0011 1111 1111 = 0 (demical) = NOT `$t1`

ìœ„ì˜ ì˜ˆì‹œì—ì„œ ì•Œ ìˆ˜ ìˆë“¯ì´ **ë§Œì•½ í•œ í”¼ì—°ì‚°ìê°€ 0ì´ë¼ë©´, NOR ì—°ì‚°ì€ ë‹¤ë¥¸ í”¼ì—°ì‚°ìì˜ NOT ì—°ì‚°ê³¼ ë™ì¼**
  * MIPSì—ëŠ” ë³„ë„ì˜ NOT ì—°ì‚°ìê°€ ì—†ì§€ë§Œ, NOR ì—°ì‚°ì„ í™œìš©í•˜ì—¬ NOT ì—°ì‚°ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŒ

## DECISION-MAKING INSTRUCTIONS
---
### Branch Instructions
---
__**Conditional Branches**__:  
* `beq`(Branch if Equal): **ë‘ ë ˆì§€ìŠ¤í„° ê°’ì´ ê°™ìœ¼ë©´ ì§€ì •ëœ labelë¡œ ë¶„ê¸°**
```
beq $s0, $s1, Label  # $s0 == $s1ì´ë©´ Labelë¡œ ì´ë™
```

* `bne`(Branch if Not Equal): **ë‘ ë ˆì§€ìŠ¤í„° ê°’ì´ ë‹¤ë¥´ë©´ ì§€ì •ëœ labelë¡œ ë¶„ê¸°**
```
bne $s0, $s1, Label  # $s0 != $s1ì´ë©´ Labelë¡œ ì´ë™
```

__**Unconditional Branche**__:  
* `j`(Jump): **í•­ìƒ ì§€ì •ëœ labelë¡œ ë¶„ê¸°**
```
j Label  # í•­ìƒ Labelë¡œ ì´ë™
```

### if-else Instructions
---
`if-else` êµ¬ë¬¸ì€ MIPS ì–´ì…ˆë¸”ë¦¬ì—ì„œ **branch intructionì„ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„ê°€ëŠ¥.**

**__ì˜ˆì‹œ__:**  
C ì–¸ì–´ ì½”ë“œ:
```c
if (i == j)
    f = g + h;
else
    f = g - h;
```

MIPS ì–´ì…ˆë¸”ë¦¬ ì½”ë“œ (f=`$s0`, g=`$s1`, h=`$s2`, i=`$s3`, j=`$s4`):
```
bne $s3, $s4, Else  # i != jì´ë©´ Elseë¡œ ì´ë™
add $s0, $s1, $s2    # f = g + h (i == jì¸ ê²½ìš°)
j Exit               # Exitë¡œ ì´ë™
Else:                # Else ë ˆì´ë¸”
sub $s0, $s1, $s2    # f = g - h (i != jì¸ ê²½ìš°)
Exit:                # Exit ë ˆì´ë¸”
```

### while
---
`while loop`ë„ **branch intructionì„ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„**
**__ì˜ˆì‹œ__:**  
C ì–¸ì–´ ì½”ë“œ:
```c
while (save[i] == k)
    i += 1;
```

MIPS ì–´ì…ˆë¸”ë¦¬ ì½”ë“œ (i=`$s3`, k=`$s5`, **`save` ë°°ì—´ì˜ ê¸°ë³¸ ì£¼ì†ŒëŠ” $s6**):
```
Loop:
    sll $t1, $s3, 2     # $t1 = i * 4 (ë°”ì´íŠ¸ ë‹¨ìœ„ ì¸ë±ìŠ¤ ê³„ì‚°)
    add $t1, $t1, $s6   # $t1 = save[i]ì˜ ì£¼ì†Œ
    lw $t0, 0($t1)      # $t0 = save[i]ì˜ ê°’
    bne $t0, $s5, Exit  # save[i] != kì´ë©´ Exitë¡œ ì´ë™
    addi $s3, $s3, 1    # i = i + 1
    j Loop              # Loopë¡œ ì´ë™
Exit:
```

### Comparison Instructions
---
* `slt`(Set Less Than): ì²« ë²ˆì§¸ ë ˆì§€ìŠ¤í„°ê°€ ë‘ ë²ˆì§¸ ë ˆì§€ìŠ¤í„°ë³´ë‹¤ **ì‘ìœ¼ë©´ ëª©ì  ë ˆì§€ìŠ¤í„°ë¥¼ 1ë¡œ ì„¤ì •, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ 0ìœ¼ë¡œ ì„¤ì •**
```
slt $t0, $s1, $s2  # $s1 < $s2ì´ë©´ $t0 = 1, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ $t0 = 0
```
* `slti`(Set Less Than Immediate): ë ˆì§€ìŠ¤í„°ê°€ **ì¦‰ì‹œê°’ë³´ë‹¤ ì‘ìœ¼ë©´ ëª©ì  ë ˆì§€ìŠ¤í„°ë¥¼ 1ë¡œ ì„¤ì •**
```
slti $t0, $s1, 100  # $s1 < 100ì´ë©´ $t0 = 1, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ $t0 = 0
```

### for
---
**__ì˜ˆì‹œ__:**  
C ì–¸ì–´ ì½”ë“œ:
```c
for (i = 0; i < 4; i++) {
    // ë¬´ì–¸ê°€ ìˆ˜í–‰
}
```

MIPS ì–´ì…ˆë¸”ë¦¬ ì½”ë“œ (i=`$t0`):
```
add $t0, $zero, $zero  # i = 0
Loop:
    slti $t1, $t0, 4     # $t1 = (i < 4 ? 1 : 0)
    beq $t1, $zero, Exit # $t1 == 0ì´ë©´ (i >= 4) Exitë¡œ ì´ë™
    # ì—¬ê¸°ì„œ ë¬´ì–¸ê°€ ìˆ˜í–‰
    addi $t0, $t0, 1     # i++
    j Loop               # Loopë¡œ ì´ë™
Exit:
```